<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug WebAV Player</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #000; color: #0f0; }
        .error { color: #f00; background: #300; padding: 10px; margin: 5px 0; }
        .success { color: #0f0; background: #030; padding: 10px; margin: 5px 0; }
        .warning { color: #ff0; background: #330; padding: 10px; margin: 5px 0; }
        pre { background: #111; padding: 15px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>ğŸ” WebAV Player é”™è¯¯è¯Šæ–­</h1>
    <div id="status">æ­£åœ¨æ£€æŸ¥...</div>
    <div id="errors"></div>
    
    <script>
        const statusEl = document.getElementById('status');
        const errorsEl = document.getElementById('errors');
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = message;
            errorsEl.appendChild(div);
            console.log(message);
        }
        
        function updateStatus(message) {
            statusEl.innerHTML = message;
        }
        
        // æ•è·æ‰€æœ‰é”™è¯¯
        window.addEventListener('error', (e) => {
            log(`âŒ ERROR: ${e.message}<br>æ–‡ä»¶: ${e.filename}<br>è¡Œå·: ${e.lineno}<br>åˆ—å·: ${e.colno}<br>å †æ ˆ: ${e.error?.stack || 'N/A'}`, 'error');
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            log(`âŒ PROMISE REJECTION: ${e.reason}<br>å †æ ˆ: ${e.reason?.stack || 'N/A'}`, 'error');
        });
        
        async function diagnose() {
            updateStatus('ğŸ” å¼€å§‹è¯Šæ–­...');
            
            try {
                // 1. æ£€æŸ¥åŸºç¡€ç¯å¢ƒ
                log('=== åŸºç¡€ç¯å¢ƒæ£€æŸ¥ ===');
                log(`âœ“ Node ç¯å¢ƒ: ${typeof process !== 'undefined' ? 'YES' : 'NO'}`);
                log(`âœ“ æµè§ˆå™¨ç¯å¢ƒ: ${typeof window !== 'undefined' ? 'YES' : 'NO'}`);
                log(`âœ“ ES Modules: ${typeof import !== 'undefined' ? 'YES' : 'NO'}`);
                log(`âœ“ WebAssembly: ${typeof WebAssembly !== 'undefined' ? 'YES' : 'NO'}`);
                log(`âœ“ SharedArrayBuffer: ${typeof SharedArrayBuffer !== 'undefined' ? 'YES' : 'NO'}`);
                
                // 2. æ£€æŸ¥polyfills
                log('<br>=== Polyfills æ£€æŸ¥ ===');
                log(`âœ“ crypto: ${typeof crypto !== 'undefined' ? 'YES' : 'NO'}`);
                log(`âœ“ crypto.getRandomValues: ${typeof crypto?.getRandomValues === 'function' ? 'YES' : 'NO'}`);
                log(`âœ“ global: ${typeof global !== 'undefined' ? 'YES' : 'NO'}`);
                log(`âœ“ process: ${typeof process !== 'undefined' ? 'YES' : 'NO'}`);
                
                // æµ‹è¯•crypto
                if (crypto && crypto.getRandomValues) {
                    const testArray = new Uint8Array(4);
                    crypto.getRandomValues(testArray);
                    log(`âœ“ crypto.getRandomValues å·¥ä½œæ­£å¸¸: [${Array.from(testArray)}]`, 'success');
                } else {
                    log('âŒ crypto.getRandomValues ä¸å¯ç”¨', 'error');
                }
                
                // 3. å°è¯•åŠ è½½æ¨¡å—
                log('<br>=== æ¨¡å—åŠ è½½æµ‹è¯• ===');
                
                try {
                    updateStatus('ğŸ“¦ æ­£åœ¨åŠ è½½ polyfills...');
                    await import('/src/utils/polyfills.js');
                    log('âœ“ polyfills.js åŠ è½½æˆåŠŸ', 'success');
                } catch (e) {
                    log(`âŒ polyfills.js åŠ è½½å¤±è´¥: ${e.message}<br>å †æ ˆ: ${e.stack}`, 'error');
                }
                
                try {
                    updateStatus('ğŸ“¦ æ­£åœ¨åŠ è½½ player...');
                    const playerModule = await import('/src/player.js');
                    log('âœ“ player.js åŠ è½½æˆåŠŸ', 'success');
                    log(`âœ“ WebAVPlayer ç±»å¯ç”¨: ${typeof playerModule.WebAVPlayer === 'function' ? 'YES' : 'NO'}`);
                } catch (e) {
                    log(`âŒ player.js åŠ è½½å¤±è´¥: ${e.message}<br>å †æ ˆ: ${e.stack}`, 'error');
                }
                
                // 4. å°è¯•åˆå§‹åŒ–æ’­æ”¾å™¨
                log('<br>=== æ’­æ”¾å™¨åˆå§‹åŒ–æµ‹è¯• ===');
                try {
                    updateStatus('ğŸ® æ­£åœ¨åˆå§‹åŒ–æ’­æ”¾å™¨...');
                    
                    // åˆ›å»ºæµ‹è¯•canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = 800;
                    canvas.height = 600;
                    
                    const { WebAVPlayer } = await import('/src/player.js');
                    const player = new WebAVPlayer(canvas);
                    log('âœ“ WebAVPlayer å®ä¾‹åŒ–æˆåŠŸ', 'success');
                    
                    updateStatus('âœ… è¯Šæ–­å®Œæˆ');
                    
                } catch (e) {
                    log(`âŒ æ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥: ${e.message}<br>å †æ ˆ: ${e.stack}`, 'error');
                    updateStatus('âŒ è¯Šæ–­å‘ç°é—®é¢˜');
                }
                
            } catch (e) {
                log(`âŒ è¯Šæ–­è¿‡ç¨‹å‡ºé”™: ${e.message}<br>å †æ ˆ: ${e.stack}`, 'error');
                updateStatus('âŒ è¯Šæ–­å¤±è´¥');
            }
        }
        
        // å¼€å§‹è¯Šæ–­
        diagnose();
    </script>
</body>
</html>