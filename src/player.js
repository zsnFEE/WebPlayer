import { WebGPURenderer } from './render/webgpu-renderer.js';
import { WebGLRenderer } from './render/webgl-renderer.js';
import { AudioPlayer } from './audio/audio-player.js';
import { WebCodecsDecoder } from './decoder/webcodecs-decoder.js';
import { FFmpegDecoder } from './decoder/ffmpeg-decoder.js';
import { MP4Parser } from './parser/mp4-parser.js';
import { sharedBufferManager } from './utils/shared-buffer.js';

/**
 * ‰∏ªÊí≠ÊîæÂô®Á±ª - ÂÆåÊï¥ÂäüËÉΩÁâàÊú¨
 * ÊîØÊåÅÔºöÊµÅÂºèÊí≠Êîæ„ÄÅÂø´ÈÄüËµ∑Êí≠„ÄÅÂ§öÂ£∞ÈÅìÈü≥È¢ë„ÄÅH264/H265„ÄÅOffscreenCanvas
 */
export class WebAVPlayer {
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = null;
    this.audioPlayer = new AudioPlayer();
    this.decoder = null;
    this.parser = new MP4Parser();
    
    // Êí≠ÊîæÁä∂ÊÄÅ
    this.isPlaying = false;
    this.currentTime = 0;
    this.duration = 0;
    this.volume = 1.0;
    this.playbackRate = 1.0;
    this.mediaInfo = null;
    
    // ÊµÅÂºèÊí≠ÊîæÂíåÁºìÂÜ≤
    this.isLoading = false;
    this.isStreaming = false;
    this.fastStartEnabled = false;
    this.minBufferForPlay = 2.0; // 2ÁßíÁºìÂÜ≤
    this.videoFrameQueue = [];
    this.audioFrameQueue = [];
    this.maxVideoQueue = 30; // ÊúÄÂ§öÁºìÂ≠ò30Â∏ßËßÜÈ¢ë
    this.maxAudioQueue = 50; // ÊúÄÂ§öÁºìÂ≠ò50Â∏ßÈü≥È¢ë
    
    // Êó∂Èó¥ÂêåÊ≠•
    this.lastVideoTime = 0;
    this.lastAudioTime = 0;
    this.startTime = 0;
    this.pausedTime = 0;
    
    // Â§öÂ£∞ÈÅìÊîØÊåÅ
    this.audioChannels = 2;
    this.channelLayout = 'stereo';
    this.surroundSound = false;
    
    // ‰∫ã‰ª∂ÂõûË∞É
    this.onTimeUpdate = null;
    this.onDurationChange = null;
    this.onLoadStart = null;
    this.onLoadEnd = null;
    this.onError = null;
    this.onPlayStateChange = null;
    this.onBufferingStart = null;
    this.onBufferingEnd = null;
    this.onFastStartReady = null;
    
    // ÊÄßËÉΩÁõëÊéß
    this.stats = {
      framesDecoded: 0,
      framesDropped: 0,
      audioSamplesDecoded: 0,
      bufferHealth: 0,
      renderFps: 0,
      bitrateKbps: 0
    };
    
    // Ë¥®ÈáèËá™ÈÄÇÂ∫î
    this.adaptiveQuality = true;
    this.targetLatency = 100; // 100msÁõÆÊ†áÂª∂Ëøü
    
    this.initialize();
  }

  /**
   * ÂàùÂßãÂåñÊí≠ÊîæÂô®
   */
  async initialize() {
    try {
      // ÂàùÂßãÂåñÊ∏≤ÊüìÂô® (‰ºòÂÖàWebGPU)
      await this.initRenderer();
      
      // ÂàùÂßãÂåñÈü≥È¢ëÊí≠ÊîæÂô®
      await this.audioPlayer.init();
      
      // ÂàùÂßãÂåñËß£Á†ÅÂô® (‰ºòÂÖàWebCodecs)
      await this.initDecoder();
      
      // ËÆæÁΩÆËß£ÊûêÂô®ÂõûË∞É
      await this.setupParserCallbacks();
      
      // ËÆæÁΩÆÈü≥È¢ëÊí≠ÊîæÂô®ÂõûË∞É
      this.setupAudioCallbacks();
      
      // ÂêØÂä®ÊÄßËÉΩÁõëÊéß
      this.startPerformanceMonitoring();
      
      console.log('WebAV Player initialized successfully with enhanced features');
      
    } catch (error) {
      console.error('Failed to initialize player:', error);
      
      // Â∞ùËØïÊèê‰æõÊúâÁî®ÁöÑÈîôËØØ‰ø°ÊÅØ
      let errorMessage = 'Failed to initialize player';
      
      if (error.message.includes('WebGPU') && error.message.includes('WebGL')) {
        errorMessage = 'No supported rendering engine found. Please use a modern browser.';
      } else if (error.message.includes('AudioWorklet')) {
        errorMessage = 'Audio initialization failed. Please check browser audio permissions.';
      } else if (error.message.includes('decoder')) {
        errorMessage = 'Video decoder initialization failed. Some codecs may not be supported.';
      }
      
      if (this.onError) {
        this.onError(new Error(errorMessage));
      }
      
      throw error;
    }
  }

  /**
   * ÂàùÂßãÂåñÊ∏≤ÊüìÂô®
   */
  async initRenderer() {
    console.log('üé® [Player] Initializing renderer...');
    
    try {
      // Â∞ùËØï‰ΩøÁî®WebGPU
      console.log('üöÄ [Player] Attempting WebGPU initialization...');
      this.renderer = new WebGPURenderer(this.canvas);
      await this.renderer.init();
      console.log('‚úÖ [Player] Using WebGPU renderer');
    } catch (error) {
      console.warn('‚ö†Ô∏è [Player] WebGPU failed, falling back to WebGL:', error);
      
      // Ê∏ÖÁêÜÂ§±Ë¥•ÁöÑWebGPUÂÆû‰æã
      if (this.renderer) {
        try {
          this.renderer.destroy();
        } catch (e) {
          console.warn('Failed to cleanup WebGPU renderer:', e);
        }
        this.renderer = null;
      }
      
      try {
        // ÂêéÂ§áÂà∞WebGL
        console.log('üîÑ [Player] Initializing WebGL renderer...');
        this.renderer = new WebGLRenderer(this.canvas);
        await this.renderer.init();
        console.log('‚úÖ [Player] Using WebGL renderer');
      } catch (webglError) {
        console.error('‚ùå [Player] Both WebGPU and WebGL failed:', webglError);
        throw new Error('No supported renderer available');
      }
    }
  }

  /**
   * ÂàùÂßãÂåñËß£Á†ÅÂô®
   */
  async initDecoder() {
    let webcodecsError = null;
    let ffmpegError = null;
    
    try {
      // Â∞ùËØï‰ΩøÁî®WebCodecs
      this.decoder = new WebCodecsDecoder();
      
      // WebCodecsËß£Á†ÅÂô®‰∏çÈúÄË¶ÅasyncÂàùÂßãÂåñÔºå‰ΩÜÈúÄË¶ÅÊ£ÄÊü•ÊîØÊåÅ
      if (!this.decoder.isVideoSupported && !this.decoder.isAudioSupported) {
        throw new Error('WebCodecs not supported for video or audio');
      }
      
      console.log('Using WebCodecs decoder');
    } catch (error) {
      webcodecsError = error;
      console.warn('WebCodecs failed, falling back to FFmpeg:', error);
      
      try {
        // ÂêéÂ§áÂà∞FFmpeg.wasm
        this.decoder = new FFmpegDecoder();
        await this.decoder.init();
        console.log('Using FFmpeg decoder');
      } catch (ffmpegError) {
        console.error('Both WebCodecs and FFmpeg failed:', ffmpegError);
        
        // Â¶ÇÊûú‰∏§‰∏™ÈÉΩÂ§±Ë¥•‰∫ÜÔºåÊäõÂá∫Êõ¥ËØ¶ÁªÜÁöÑÈîôËØØ
        const detailedError = new Error(
          `No supported decoder available. WebCodecs: ${webcodecsError?.message || 'not supported'}. FFmpeg: ${ffmpegError?.message || 'failed to load'}`
        );
        
        throw detailedError;
      }
    }
    
    // ËÆæÁΩÆËß£Á†ÅÂô®ÂõûË∞É
    this.decoder.onVideoFrame = (frame) => {
      this.handleVideoFrame(frame);
    };
    
    this.decoder.onAudioFrame = (frame) => {
      this.handleAudioFrame(frame);
    };
  }

  /**
   * ËÆæÁΩÆËß£ÊûêÂô®ÂõûË∞É - Â¢ûÂº∫Áâà
   */
  async setupParserCallbacks() {
    // È¶ñÂÖàÂàùÂßãÂåñËß£ÊûêÂô®
    await this.parser.init();
    
    this.parser.onReady = (info) => {
      this.handleMediaReady(info);
    };
    
    this.parser.onSamples = (trackId, samples) => {
      this.handleSamples(trackId, samples);
    };
    
    this.parser.onError = (error) => {
      if (this.onError) {
        this.onError(error);
      }
    };
    
    // ÊµÅÂºèÊí≠ÊîæÂõûË∞É
    this.parser.onProgress = (loaded, total) => {
      this.updateLoadingProgress(loaded, total);
    };
    
    this.parser.onFastStartReady = () => {
      this.handleFastStartReady();
    };
  }

  /**
   * Â§ÑÁêÜÂø´ÈÄüËµ∑Êí≠Â∞±Áª™
   */
  handleFastStartReady() {
    this.fastStartEnabled = true;
    console.log('Fast start ready - can begin playback');
    
    if (this.onFastStartReady) {
      this.onFastStartReady();
    }
    
    // Â¶ÇÊûúÂ∑≤ÁªèÂºÄÂßãÊí≠ÊîæÔºåÁªßÁª≠Â§ÑÁêÜ
    if (this.isPlaying) {
      this.resumePlayback();
    }
  }

  /**
   * Â§ÑÁêÜÂ™í‰Ωì‰ø°ÊÅØÂ∞±Áª™ - Â¢ûÂº∫Áâà
   */
  async handleMediaReady(info) {
    console.log('üéØ [Player] handleMediaReady called with info:', info);
    
    if (!info) {
      console.error('‚ùå [Player] No media info received!');
      return;
    }
    
    if (!info.tracks || info.tracks.length === 0) {
      console.error('‚ùå [Player] No tracks found in media info!');
      return;
    }
    
    this.mediaInfo = info;
    this.duration = info.duration / info.timescale;
    this.isStreaming = info.isStreaming || false;
    
    console.log('üìä [Player] Processed media info:', {
      duration: this.duration,
      isStreaming: this.isStreaming,
      hasVideo: info.hasVideo,
      hasAudio: info.hasAudio,
      tracksCount: info.tracks.length,
      timescale: info.timescale,
      rawDuration: info.duration
    });
    
    // È™åËØÅtracks
    const videoTracks = info.tracks.filter(t => t.type === 'video');
    const audioTracks = info.tracks.filter(t => t.type === 'audio');
    
    console.log('üé• [Player] Track analysis:', {
      videoTracks: videoTracks.length,
      audioTracks: audioTracks.length,
      allTracks: info.tracks.map(t => ({ id: t.id, type: t.type, codec: t.codec }))
    });
    
    // ËÆæÁΩÆÈü≥È¢ë‰ø°ÊÅØ
    if (info.hasAudio && this.parser.audioTrack) {
      const audioTrack = this.parser.audioTrack;
      this.audioChannels = audioTrack.audio?.channel_count || 2;
      console.log('üîä [Player] Setting up audio channels:', this.audioChannels);
      this.setupAudioChannels();
    }
    
    // ÂºÄÂßãËß£Á†ÅÂô®ÂàùÂßãÂåñ
    console.log('‚öôÔ∏è [Player] Initializing decoders with media info...');
    try {
      await this.initDecodersWithMediaInfo();
      console.log('‚úÖ [Player] Decoder initialization completed successfully');
    } catch (error) {
      console.error('‚ùå [Player] Decoder initialization failed:', error);
    }
    
    if (this.onDurationChange) {
      console.log('‚è±Ô∏è [Player] Calling onDurationChange callback:', this.duration);
      this.onDurationChange(this.duration);
    }
    
    // Âª∂ËøüÊ£ÄÊü•Ëß£Á†ÅÂô®Áä∂ÊÄÅ
    setTimeout(() => {
      console.log('üîç [Player] Final decoder status check:', {
        hasDecoder: !!this.decoder,
        decoderType: this.decoder?.constructor?.name,
        decoderState: this.decoder ? 'initialized' : 'null'
      });
    }, 100);
    
    console.log('‚úÖ [Player] Media ready - final state:', {
      duration: this.duration,
      hasVideo: info.hasVideo,
      hasAudio: info.hasAudio,
      isStreaming: this.isStreaming,
      audioChannels: this.audioChannels,
      hasDecoder: !!this.decoder,
      hasRenderer: !!this.renderer,
      hasAudioPlayer: !!this.audioPlayer
    });

    // Ëß¶ÂèëÂ™í‰ΩìÂ∞±Áª™ÂõûË∞É
    if (this.onMediaReady) {
      console.log('üì¢ [Player] Calling onMediaReady callback...');
      this.onMediaReady();
    } else {
      console.warn('‚ö†Ô∏è [Player] No onMediaReady callback set!');
    }
  }

  /**
   * ËÆæÁΩÆÈü≥È¢ëÂ£∞ÈÅì
   */
  setupAudioChannels() {
    // Ê†πÊçÆÂ£∞ÈÅìÊï∞Á°ÆÂÆöÂ∏ÉÂ±Ä
    switch (this.audioChannels) {
      case 1:
        this.channelLayout = 'mono';
        break;
      case 2:
        this.channelLayout = 'stereo';
        break;
      case 6:
        this.channelLayout = '5.1';
        this.surroundSound = true;
        break;
      case 8:
        this.channelLayout = '7.1';
        this.surroundSound = true;
        break;
      default:
        this.channelLayout = 'stereo';
        this.audioChannels = 2;
    }
    
    // ÈÖçÁΩÆAudioWorklet
    this.audioPlayer.workletNode?.port.postMessage({
      type: 'channel-mapping',
      mapping: this.channelLayout
    });
    
    this.audioPlayer.workletNode?.port.postMessage({
      type: 'surround-mode',
      enabled: this.surroundSound
    });
    
    console.log(`Audio setup: ${this.audioChannels} channels, ${this.channelLayout} layout`);
  }

  /**
   * ‰ΩøÁî®Â™í‰Ωì‰ø°ÊÅØÂàùÂßãÂåñËß£Á†ÅÂô®
   */
  async initDecodersWithMediaInfo() {
    console.log('üîß [Player] initDecodersWithMediaInfo started');
    console.log('üìä [Player] MediaInfo check:', {
      hasMediaInfo: !!this.mediaInfo,
      hasDecoder: !!this.decoder,
      mediaInfo: this.mediaInfo
    });
    
    if (!this.mediaInfo) {
      console.error('‚ùå [Player] No media info available for decoder initialization');
      return;
    }
    
    if (!this.decoder) {
      console.error('‚ùå [Player] No decoder available for initialization');
      return;
    }
    
    try {
      // ÂàùÂßãÂåñËßÜÈ¢ëËß£Á†ÅÂô®
      if (this.mediaInfo.hasVideo && this.parser.videoTrack) {
        console.log('üé• [Player] Initializing video decoder...');
        console.log('üé¨ [Player] Video track info:', this.parser.videoTrack);
        
        const videoConfig = this.createVideoConfig();
        console.log('‚öôÔ∏è [Player] Video config:', videoConfig);
        
        await this.decoder.initVideoDecoder(videoConfig);
        console.log('‚úÖ [Player] Video decoder initialized successfully');
      } else {
        console.log('‚ö†Ô∏è [Player] Skipping video decoder - hasVideo:', this.mediaInfo.hasVideo, 'videoTrack:', !!this.parser.videoTrack);
      }
      
      // ÂàùÂßãÂåñÈü≥È¢ëËß£Á†ÅÂô®  
      if (this.mediaInfo.hasAudio && this.parser.audioTrack) {
        console.log('üîä [Player] Initializing audio decoder...');
        console.log('üéµ [Player] Audio track info:', this.parser.audioTrack);
        
        const audioConfig = this.createAudioConfig();
        console.log('‚öôÔ∏è [Player] Audio config:', audioConfig);
        
        await this.decoder.initAudioDecoder(audioConfig);
        console.log('‚úÖ [Player] Audio decoder initialized successfully');
      } else {
        console.log('‚ö†Ô∏è [Player] Skipping audio decoder - hasAudio:', this.mediaInfo.hasAudio, 'audioTrack:', !!this.parser.audioTrack);
      }
      
      console.log('‚úÖ [Player] All decoders initialized with media info');
      
    } catch (error) {
      console.error('‚ùå [Player] Failed to initialize decoders with media info:', error);
      console.error('Error details:', {
        message: error.message,
        stack: error.stack,
        name: error.name
      });
      
      if (this.onError) {
        this.onError(error);
      }
      throw error; // ÈáçÊñ∞ÊäõÂá∫‰ª•‰æø‰∏äÂ±ÇÂ§ÑÁêÜ
    }
  }

  /**
   * ÂàõÂª∫ËßÜÈ¢ëÈÖçÁΩÆ
   */
  createVideoConfig() {
    const track = this.parser.videoTrack;
    
    return {
      codec: track.codec,
      codedWidth: track.video.width,
      codedHeight: track.video.height,
      description: track.avcDecoderConfigRecord || track.hvcDecoderConfigRecord,
      hardwareAcceleration: 'prefer-hardware',
      optimizeForLatency: true
    };
  }

  /**
   * ÂàõÂª∫Èü≥È¢ëÈÖçÁΩÆ
   */
  createAudioConfig() {
    const track = this.parser.audioTrack;
    
    return {
      codec: track.codec,
      sampleRate: track.audio.sample_rate,
      numberOfChannels: track.audio.channel_count,
      description: track.esdsBox?.data
    };
  }

  /**
   * Âä†ËΩΩÂ™í‰ΩìÊñá‰ª∂
   */
  async loadFile(file) {
    console.log('üé¨ [Player] loadFile() called with:', file);
    
    this.reset();
    this.setLoading(true);
    
    try {
      if (file instanceof File) {
        console.log('üìÅ [Player] Loading local file...');
        await this.loadLocalFile(file);
      } else if (typeof file === 'string') {
        console.log('üåê [Player] Loading URL...');
        await this.loadFromURL(file);
      } else {
        throw new Error('Unsupported file type');
      }
      
      console.log('‚úÖ [Player] File load process completed');
      
    } catch (error) {
      console.error('‚ùå [Player] Failed to load file:', error);
      this.setLoading(false);
      if (this.onError) {
        this.onError(error);
      }
      throw error; // ÈáçÊñ∞ÊäõÂá∫ÈîôËØØ‰ª•‰æø‰∏äÂ±ÇÂ§ÑÁêÜ
    }
  }

  /**
   * Âä†ËΩΩÊú¨Âú∞Êñá‰ª∂
   */
  async loadLocalFile(file) {
    console.log('üìÅ [Player] loadLocalFile started');
    
    try {
      console.log('üìñ [Player] Reading file as ArrayBuffer...');
      const arrayBuffer = await file.arrayBuffer();
      
      console.log(`üìä [Player] File read complete: ${arrayBuffer.byteLength} bytes`);
      
      console.log('üì¶ [Player] Sending to parser...');
      await this.parser.appendBuffer(arrayBuffer);
      
      console.log('‚úÖ [Player] Local file processing initiated');
      // Ê≥®ÊÑèÔºö‰∏çÈúÄË¶ÅË∞ÉÁî® this.parser.start()ÔºåappendBufferÂÜÖÈÉ®Â∑≤ÁªèÂ§ÑÁêÜ
      
    } catch (error) {
      console.error('‚ùå [Player] Failed to load local file:', error);
      if (this.onError) {
        this.onError(error);
      }
      throw error;
    }
  }

  /**
   * ‰ªéURLÂä†ËΩΩ (ÊîØÊåÅÊµÅÂºè)
   */
  async loadFromURL(url) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const reader = response.body.getReader();
    
    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        // ÊµÅÂºèÊ∑ªÂä†Êï∞ÊçÆ
        await this.parser.appendBuffer(value.buffer);
        
        // Â¶ÇÊûúËøòÊ≤°ÂºÄÂßãÔºåÂ∞ùËØïÂºÄÂßãËß£Êûê
        if (!this.parser.isInitialized && this.parser.info) {
          this.parser.start();
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  // Âà†Èô§ÈáçÂ§çÁöÑhandleMediaReadyÊñπÊ≥ï - ‰ΩøÁî®Â¢ûÂº∫ÁâàÊú¨

  /**
   * Â§ÑÁêÜÊ†∑Êú¨Êï∞ÊçÆ
   */
  handleSamples(trackId, samples) {
    for (const sample of samples) {
      const sampleData = this.parser.getSampleData(sample);
      
      if (trackId === this.parser.videoTrack?.id) {
        // ËßÜÈ¢ëÊ†∑Êú¨
        this.decoder.decodeVideo(
          sampleData.data,
          sampleData.timestamp,
          sampleData.isSync
        );
      } else if (trackId === this.parser.audioTrack?.id) {
        // Èü≥È¢ëÊ†∑Êú¨
        this.decoder.decodeAudio(
          sampleData.data,
          sampleData.timestamp
        );
      }
    }
  }

  /**
   * Â§ÑÁêÜËßÜÈ¢ëÂ∏ß
   */
  handleVideoFrame(frame) {
    console.log('üé¨ [Player] handleVideoFrame called:', {
      hasFrame: !!frame,
      width: frame?.width,
      height: frame?.height,
      timestamp: frame?.timestamp,
      hasImageData: !!(frame?.imageData)
    });
    
    if (!frame || !frame.imageData || !frame.width || !frame.height) {
      console.warn('‚ö†Ô∏è [Player] Invalid video frame received');
      return;
    }
    
    this.stats.framesDecoded++;
    
    try {
      // Áõ¥Êé•Ê∏≤ÊüìÂ∏ßÔºå‰∏ç‰ΩøÁî®Â§çÊùÇÁöÑÈòüÂàóÁ≥ªÁªü
      if (this.renderer) {
        console.log('üñºÔ∏è [Player] Rendering frame directly to renderer');
        this.renderer.renderFrame(frame.imageData.data, frame.width, frame.height);
      } else {
        console.warn('‚ö†Ô∏è [Player] No renderer available, using fallback Canvas 2D');
        this.fallbackRender(frame);
      }
      
    } catch (error) {
      console.error('‚ùå [Player] Error handling video frame:', error);
    }
  }

  /**
   * Â§ÑÁêÜÈü≥È¢ëÂ∏ß
   */
  handleAudioFrame(frame) {
    console.log('üîä [Player] handleAudioFrame called:', {
      hasFrame: !!frame,
      dataLength: frame?.data?.length,
      channelCount: frame?.channelCount,
      sampleRate: frame?.sampleRate,
      timestamp: frame?.timestamp
    });
    
    if (!frame || !frame.data || !frame.channelCount) {
      console.warn('‚ö†Ô∏è [Player] Invalid audio frame received');
      return;
    }
    
    this.stats.audioSamplesDecoded += frame.data.length;
    
    try {
      // Áõ¥Êé•ÂèëÈÄÅÂà∞Èü≥È¢ëÊí≠ÊîæÂô®Ôºå‰∏ç‰ΩøÁî®SharedArrayBuffer
      if (this.audioPlayer) {
        console.log('üéµ [Player] Sending audio data to player');
        this.audioPlayer.addAudioData(frame.data.buffer, frame.timestamp);
      } else {
        console.warn('‚ö†Ô∏è [Player] No audio player available for frame');
      }
      
    } catch (error) {
      console.error('‚ùå [Player] Error handling audio frame:', error);
    }
  }

  // renderCurrentFrame method removed - now rendering directly in handleVideoFrame

  /**
   * ÈôçÁ∫ßCanvas 2DÊ∏≤Êüì
   */
  fallbackRender(frame) {
    try {
      console.log('üé® [Player] Using Canvas 2D fallback rendering');
      
      // ËÆæÁΩÆÁîªÂ∏ÉÂ∞∫ÂØ∏
      if (this.canvas.width !== frame.width || this.canvas.height !== frame.height) {
        this.canvas.width = frame.width;
        this.canvas.height = frame.height;
        console.log(`üìê [Player] Canvas resized to ${frame.width}x${frame.height}`);
      }
      
      const ctx = this.canvas.getContext('2d');
      if (ctx && frame.imageData) {
        ctx.putImageData(frame.imageData, 0, 0);
        console.log('‚úÖ [Player] Frame rendered with Canvas 2D');
      } else {
        console.error('‚ùå [Player] Failed to get 2D context or imageData');
      }
      
    } catch (error) {
      console.error('‚ùå [Player] Canvas 2D fallback failed:', error);
    }
  }

  /**
   * Êí≠Êîæ
   */
  async play() {
    console.log('‚ñ∂Ô∏è [Player] play() called');
    console.log('üé¨ [Player] Current state check:', {
      hasMediaInfo: !!this.mediaInfo,
      hasDecoder: !!this.decoder,
      hasRenderer: !!this.renderer,
      hasAudioPlayer: !!this.audioPlayer,
      duration: this.duration,
      currentTime: this.currentTime
    });
    
    if (!this.mediaInfo) {
      console.warn('‚ö†Ô∏è [Player] No media loaded - cannot play');
      return;
    }
    
    if (!this.decoder) {
      console.error('‚ùå [Player] No decoder available - cannot play');
      return;
    }
    
    if (!this.renderer) {
      console.error('‚ùå [Player] No renderer available - cannot play');
      return;
    }

    console.log('‚úÖ [Player] All components ready, starting playback...');
    this.isPlaying = true;
    
    try {
      await this.audioPlayer.play();
      console.log('üîä [Player] Audio player started successfully');
    } catch (error) {
      console.error('‚ùå [Player] Failed to start audio player:', error);
    }
    
    if (this.onPlayStateChange) {
      console.log('üì¢ [Player] Calling onPlayStateChange(true)');
      this.onPlayStateChange(true);
    } else {
      console.warn('‚ö†Ô∏è [Player] No onPlayStateChange callback set');
    }
    
    console.log('‚úÖ [Player] Play initiated successfully');
  }

  /**
   * ÊöÇÂÅú
   */
  pause() {
    this.isPlaying = false;
    this.audioPlayer.pause();
    
    if (this.onPlayStateChange) {
      this.onPlayStateChange(false);
    }
  }

  /**
   * Ë∑≥ËΩ¨
   */
  seek(time) {
    if (!this.mediaInfo) return;
    
    time = Math.max(0, Math.min(time, this.duration));
    this.currentTime = time;
    
    // Ê∏ÖÈô§ÈòüÂàó
    this.videoFrameQueue = [];
    this.audioPlayer.clear();
    
    // Ëß£ÊûêÂô®Ë∑≥ËΩ¨
    this.parser.seek(time);
    
    // Èü≥È¢ëÊí≠ÊîæÂô®Ë∑≥ËΩ¨
    this.audioPlayer.seek(time);
  }

  /**
   * ËÆæÁΩÆÈü≥Èáè
   */
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
    this.audioPlayer.setVolume(this.volume);
  }

  /**
   * ËÆæÁΩÆÊí≠ÊîæÈÄüÂ∫¶
   */
  setPlaybackRate(rate) {
    this.playbackRate = Math.max(0.1, Math.min(4, rate));
    this.audioPlayer.setPlaybackRate(this.playbackRate);
  }

  /**
   * Ëé∑ÂèñÊí≠ÊîæÁä∂ÊÄÅ
   */
  getState() {
    return {
      playing: this.isPlaying,
      currentTime: this.currentTime,
      duration: this.duration,
      volume: this.volume,
      playbackRate: this.playbackRate,
      loading: this.isLoading,
      mediaInfo: this.mediaInfo,
      stats: this.stats
    };
  }

  /**
   * ËÆæÁΩÆÂä†ËΩΩÁä∂ÊÄÅ
   */
  setLoading(loading) {
    this.isLoading = loading;
    
    if (loading && this.onLoadStart) {
      this.onLoadStart();
    } else if (!loading && this.onLoadEnd) {
      this.onLoadEnd();
    }
  }

  /**
   * ÈáçÁΩÆÊí≠ÊîæÂô®
   */
  reset() {
    this.pause();
    this.currentTime = 0;
    this.duration = 0;
    this.mediaInfo = null;
    this.videoFrameQueue = [];
    this.parser.reset();
    this.audioPlayer.clear();
    
    // ÈáçÁΩÆÁªüËÆ°
    this.stats = {
      framesDecoded: 0,
      framesDropped: 0,
      audioSamplesDecoded: 0
    };
  }

  /**
   * ÈîÄÊØÅÊí≠ÊîæÂô®
   */
  destroy() {
    this.reset();
    
    if (this.renderer) {
      this.renderer.destroy();
    }
    
    if (this.audioPlayer) {
      this.audioPlayer.destroy();
    }
    
    if (this.decoder) {
      this.decoder.destroy();
    }
    
    this.parser.destroy();
  }

  /**
   * Êõ¥Êñ∞Âä†ËΩΩËøõÂ∫¶
   */
  updateLoadingProgress(loaded, total) {
    if (this.onLoadStart) {
      this.onLoadStart();
    }
    if (this.onLoadEnd) {
      this.onLoadEnd();
    }
  }

  /**
   * Êí≠ÊîæÊéßÂà∂
   */
  async play() {
    if (!this.mediaInfo) {
      console.warn('No media loaded');
      return;
    }
    
    // Ê£ÄÊü•ÁºìÂÜ≤Âå∫Áä∂ÊÄÅ
    if (this.isStreaming && !this.fastStartEnabled) {
      console.log('Waiting for fast start...');
      if (this.onBufferingStart) {
        this.onBufferingStart();
      }
      return;
    }
    
    this.isPlaying = true;
    this.startTime = performance.now() - this.pausedTime;
    
    // ÂêØÂä®Èü≥È¢ëÊí≠Êîæ
    this.audioPlayer.workletNode?.port.postMessage({ type: 'play' });
    
    // ÂêØÂä®ËßÜÈ¢ëÊ∏≤ÊüìÂæ™ÁéØ
    this.startRenderLoop();
    
    if (this.onPlayStateChange) {
      this.onPlayStateChange(true);
    }
    
    console.log('Playback started');
  }

  /**
   * ÊöÇÂÅúÊí≠Êîæ
   */
  pause() {
    this.isPlaying = false;
    this.pausedTime = performance.now() - this.startTime;
    
    // ÂÅúÊ≠¢Èü≥È¢ëÊí≠Êîæ
    this.audioPlayer.workletNode?.port.postMessage({ type: 'pause' });
    
    if (this.onPlayStateChange) {
      this.onPlayStateChange(false);
    }
    
    console.log('Playback paused');
  }

  /**
   * ÂÅúÊ≠¢Êí≠Êîæ
   */
  stop() {
    this.pause();
    this.currentTime = 0;
    this.pausedTime = 0;
    this.videoFrameQueue = [];
    this.audioFrameQueue = [];
    
    // Ê∏ÖÈô§Èü≥È¢ëÁºìÂÜ≤
    this.audioPlayer.workletNode?.port.postMessage({ type: 'clear' });
  }

  /**
   * Ë∑≥ËΩ¨Âà∞ÊåáÂÆöÊó∂Èó¥
   */
  async seek(time) {
    const targetTime = Math.max(0, Math.min(time, this.duration));
    this.currentTime = targetTime;
    
    // Ê∏ÖÈô§ÁºìÂÜ≤ÈòüÂàó
    this.videoFrameQueue = [];
    this.audioFrameQueue = [];
    
    // ÈÄöÁü•Èü≥È¢ëÂ§ÑÁêÜÂô®
    this.audioPlayer.workletNode?.port.postMessage({
      type: 'seek',
      time: targetTime
    });
    
    // Â¶ÇÊûúÊòØÊµÅÂºèÊí≠ÊîæÔºåÂèØËÉΩÈúÄË¶ÅÈáçÊñ∞ÁºìÂÜ≤
    if (this.isStreaming) {
      // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÊñ∞ÂºÄÂßãÁºìÂÜ≤
      if (this.onBufferingStart) {
        this.onBufferingStart();
      }
    }
    
    console.log(`Seeked to ${targetTime.toFixed(2)}s`);
  }

  /**
   * ËÆæÁΩÆÈü≥Èáè (0.0 - 1.0)
   */
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
    
    this.audioPlayer.workletNode?.port.postMessage({
      type: 'volume',
      volume: this.volume
    });
  }

  /**
   * ËÆæÁΩÆÊí≠ÊîæÈÄüÂ∫¶ (0.1 - 4.0)
   */
  setPlaybackRate(rate) {
    this.playbackRate = Math.max(0.1, Math.min(4, rate));
    
    this.audioPlayer.workletNode?.port.postMessage({
      type: 'playback-rate',
      rate: this.playbackRate
    });
    
    console.log(`Playback rate set to ${this.playbackRate}x`);
  }

  /**
   * ÂêØÁî®/Á¶ÅÁî®ÁéØÁªïÂ£∞
   */
  setSurroundSound(enabled) {
    this.surroundSound = enabled;
    
    this.audioPlayer.workletNode?.port.postMessage({
      type: 'surround-mode',
      enabled: this.surroundSound
    });
    
    console.log(`Surround sound ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * ÂêØÂä®Ê∏≤ÊüìÂæ™ÁéØ
   */
  startRenderLoop() {
    const renderFrame = () => {
      if (!this.isPlaying) return;
      
      this.renderVideoFrame();
      this.updateCurrentTime();
      
      // ÁªßÁª≠‰∏ã‰∏ÄÂ∏ß
      requestAnimationFrame(renderFrame);
    };
    
    requestAnimationFrame(renderFrame);
  }

  /**
   * Ê∏≤ÊüìËßÜÈ¢ëÂ∏ß
   */
  renderVideoFrame() {
    if (this.videoFrameQueue.length === 0) return;
    
    const currentPlayTime = this.getCurrentPlayTime();
    
    // Êü•ÊâæÊúÄÊé•ËøëÂΩìÂâçÊó∂Èó¥ÁöÑÂ∏ß
    let frameIndex = -1;
    for (let i = 0; i < this.videoFrameQueue.length; i++) {
      const frame = this.videoFrameQueue[i];
      if (frame.timestamp <= currentPlayTime) {
        frameIndex = i;
      } else {
        break;
      }
    }
    
    if (frameIndex >= 0) {
      const frame = this.videoFrameQueue[frameIndex];
      
      // Ê∏≤ÊüìÂ∏ß
      if (this.renderer && frame.imageData) {
        this.renderer.renderFrame(frame);
      }
      
      // ÁßªÈô§Â∑≤Ê∏≤ÊüìÁöÑÂ∏ß
      this.videoFrameQueue.splice(0, frameIndex + 1);
      this.lastVideoTime = frame.timestamp;
    }
  }

  /**
   * Ëé∑ÂèñÂΩìÂâçÊí≠ÊîæÊó∂Èó¥
   */
  getCurrentPlayTime() {
    if (!this.isPlaying) {
      return this.currentTime;
    }
    
    const elapsed = (performance.now() - this.startTime) / 1000;
    return this.currentTime + elapsed * this.playbackRate;
  }

  /**
   * Êõ¥Êñ∞ÂΩìÂâçÊó∂Èó¥
   */
  updateCurrentTime() {
    const newTime = this.getCurrentPlayTime();
    
    if (Math.abs(newTime - this.currentTime) > 0.1) {
      this.currentTime = newTime;
      
      if (this.onTimeUpdate) {
        this.onTimeUpdate(this.currentTime);
      }
    }
  }

  /**
   * ÂêØÂä®ÊÄßËÉΩÁõëÊéß
   */
  startPerformanceMonitoring() {
    setInterval(() => {
      this.updatePerformanceStats();
    }, 1000);
  }

  /**
   * Êõ¥Êñ∞ÊÄßËÉΩÁªüËÆ°
   */
  updatePerformanceStats() {
    // ËÆ°ÁÆóÁºìÂÜ≤Âå∫ÂÅ•Â∫∑Â∫¶
    const videoBufferSeconds = this.videoFrameQueue.length / 30; // ÂÅáËÆæ30fps
    const audioBufferSeconds = this.audioFrameQueue.length / 50; // ÂÅáËÆæ50Â∏ß/ÁßíÈü≥È¢ë
    this.stats.bufferHealth = Math.min(videoBufferSeconds, audioBufferSeconds);
    
    // ËÆ°ÁÆóÊ∏≤ÊüìÂ∏ßÁéá
    if (this.renderer && this.renderer.getStats) {
      const renderStats = this.renderer.getStats();
      this.stats.renderFps = renderStats.fps || 0;
    }
  }

  /**
   * Ëé∑ÂèñÊí≠ÊîæÂô®Áä∂ÊÄÅ
   */
  getState() {
    return {
      isPlaying: this.isPlaying,
      playing: this.isPlaying, // Ê∑ªÂä†playingÂà´Âêç‰ª•ÂÖºÂÆπUI‰ª£Á†Å
      currentTime: this.currentTime,
      duration: this.duration,
      volume: this.volume,
      playbackRate: this.playbackRate,
      isLoading: this.isLoading,
      isStreaming: this.isStreaming,
      fastStartEnabled: this.fastStartEnabled,
      audioChannels: this.audioChannels,
      channelLayout: this.channelLayout,
      surroundSound: this.surroundSound,
      stats: this.stats,
      mediaInfo: this.mediaInfo, // Ê∑ªÂä†mediaInfo‰ª•‰æõUIÊ£ÄÊü•
      hasDecoder: !!this.decoder,
      hasRenderer: !!this.renderer,
      hasParser: !!this.parser
    };
  }

  /**
   * Ëé∑ÂèñÊîØÊåÅÁöÑÊ†ºÂºè
   */
  async getSupportedFormats() {
    const support = {
      video: {},
      audio: {}
    };
    
    if (this.decoder && this.decoder.checkSupport) {
      // Ê£ÄÊü•Â∏∏ËßÅËßÜÈ¢ëÁºñËß£Á†ÅÂô®
      const videoCodecs = ['avc1.42E01E', 'hev1.1.6.L93.B0', 'vp09.00.10.08', 'av01.0.05M.08'];
      for (const codec of videoCodecs) {
        const result = await this.decoder.checkSupport(codec, null);
        support.video[codec] = {
          supported: result.video,
          hardwareAccelerated: result.videoHardware
        };
      }
      
      // Ê£ÄÊü•Â∏∏ËßÅÈü≥È¢ëÁºñËß£Á†ÅÂô®
      const audioCodecs = ['mp4a.40.2', 'opus', 'vorbis'];
      for (const codec of audioCodecs) {
        const result = await this.decoder.checkSupport(null, codec);
        support.audio[codec] = {
          supported: result.audio,
          hardwareAccelerated: result.audioHardware
        };
      }
    }
    
    return support;
  }
}